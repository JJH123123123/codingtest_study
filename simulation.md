
# 시뮬레이션 연습

## 1. 배열의 90도 회전

### 기본 개념
배열의 90도 회전이란, 2차원 배열을 기준으로 모든 요소를 시계 방향으로 90도 회전시키는 작업입니다. 이 작업은 배열의 행(row)을 열(column)로 변환하고, 위치를 조정하는 과정을 포함합니다.

### 상세한 설명
만약 `n x n` 배열이 있다고 가정하면, 이 배열의 90도 회전은 다음과 같이 이루어집니다:
- 0번째 행의 마지막 요소는 0번째 열의 첫 번째 요소가 됩니다.
- 1번째 행의 마지막 요소는 1번째 열의 첫 번째 요소가 됩니다.
- 이러한 패턴이 배열의 모든 요소에 적용됩니다.

### 문제
주어진 3x3 2차원 배열을 시계 방향으로 90도 회전시키는 프로그램을 작성하세요.
입력된 배열의 원소는 그대로 유지하면서, 회전된 결과를 별도의 배열에 저장합니다.
#### 예시 입력
1 2 3<br>
4 5 6<br>
7 8 9<br>

#### 예시 출력
7 4 1<br>
8 5 2<br>
9 6 3<br>

<details>
<summary>정답 코드</summary>
  
```cpp
#include <iostream>
using namespace std;



// 3x3 크기의 행렬을 전역 변수로 선언
int matrix[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// 결과를 저장할 회전된 행렬
int rotatedMatrix[3][3];

// 2차원 배열을 시계 방향으로 90도 회전시키는 함수
void rotate90(int n) {
    // 원래 배열의 각 요소를 회전된 배열의 적절한 위치로 이동
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // 회전된 배열의 요소는 원래 배열의 (i, j)에서 (j, n-1-i)로 이동
            rotatedMatrix[j][n - 1 - i] = matrix[i][j];
        }
    }
}

int main() {
    // 기존 배열 출력
    cout << "Original Matrix:" << endl;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }

    // 90도 회전을 수행하는 함수 호출
    rotate90(3);

    // 회전된 배열 출력
    cout << "Rotated Matrix (90 degrees clockwise):" << endl;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            cout << rotatedMatrix[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
```
</details>

### 코드 설명
이 코드에서는 `rotate90` 함수가 2차원 배열을 입력받아 시계 방향으로 90도 회전된 새로운 2차원 배열을 반환합니다. 이 함수는 원본 배열의 각 요소를 새로운 위치로 이동시켜 회전을 구현합니다. `main` 함수에서는 예제 배열을 만들어 회전된 결과를 출력합니다.

---

## 2. 달팽이 수열

### 기본 개념
달팽이 수열이란, 2차원 배열의 첫 번째 행부터 시작하여 배열의 경계를 따라 시계 방향으로 나선형으로 진행하면서 숫자를 채워 넣는 방식입니다. 이 방법은 배열의 모든 요소를 순서대로 채우기 위해 사용됩니다.

### 상세한 설명
달팽이 수열을 구현하려면 다음과 같은 단계를 따릅니다:
1. 왼쪽에서 오른쪽으로 이동하여 숫자를 채운 후,
2. 위에서 아래로 내려가면서 채우고,
3. 오른쪽에서 왼쪽으로 이동하며 채우고,
4. 아래에서 위로 올라가면서 채웁니다.
5. 이 과정을 배열이 채워질 때까지 반복합니다.

### 예시 코드

```cpp
#include <iostream>
using namespace std;

// 문제의 정의:
// 주어진 정수 n에 대해 n x n 크기의 2차원 배열을 달팽이 모양으로 채우는 프로그램을 작성하세요.
// 달팽이 모양은 배열의 왼쪽 위에서 시작하여, 시계 방향으로 값을 1부터 채워 나가는 형태입니다.

// 예시 입력:
// n = 5

// 예시 출력:
// 1  2  3  4  5
// 16 17 18 19 6
// 15 24 25 20 7
// 14 23 22 21 8
// 13 12 11 10 9

// n x n 크기의 달팽이 수열을 생성하는 함수
void generateSnailMatrix(int n, int matrix[5][5]) {
    int num = 1;  // 배열에 채울 숫자
    int top = 0, bottom = n - 1;  // 상하 경계
    int left = 0, right = n - 1;  // 좌우 경계

    while (num <= n * n) {
        // 왼쪽에서 오른쪽으로 채우기
        for (int i = left; i <= right; i++) {
            matrix[top][i] = num++;
        }
        top++;

        // 위에서 아래로 채우기
        for (int i = top; i <= bottom; i++) {
            matrix[i][right] = num++;
        }
        right--;

        // 오른쪽에서 왼쪽으로 채우기
        for (int i = right; i >= left; i--) {
            matrix[bottom][i] = num++;
        }
        bottom--;

        // 아래에서 위로 채우기
        for (int i = bottom; i >= top; i--) {
            matrix[i][left] = num++;
        }
        left++;
    }
}

int main() {
    int n = 5;  // n의 값 설정
    int snailMatrix[5][5];  // n x n 크기의 2차원 배열 선언

    // 달팽이 수열 생성
    generateSnailMatrix(n, snailMatrix);

    // 달팽이 수열 출력
    cout << "Snail Matrix:" << endl;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << snailMatrix[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}

```

### 코드 설명
`generateSnailMatrix` 함수는 크기 `n x n`의 2차원 배열을 생성하고, 달팽이 수열 패턴으로 숫자를 채웁니다. 각 방향으로 숫자를 채운 후, 경계를 조정하면서 반복합니다. `main` 함수에서는 5x5 크기의 배열을 생성하고 그 결과를 출력합니다.

---

## 3. 배열을 2차원 좌표로 해서 상하좌우 이동

### 기본 개념
2차원 배열에서 상하좌우로 이동하는 것은, 특정 좌표에서 상, 하, 좌, 우의 인접한 요소로 이동하는 것을 의미합니다. 이 과정은 주로 탐색 알고리즘이나 게임에서 자주 사용됩니다.

### 상세한 설명
2차원 배열에서 현재 위치에서 상하좌우로 이동하려면, 각각의 방향에 대한 좌표 변화를 이해해야 합니다:
- 상: `row - 1, col`
- 하: `row + 1, col`
- 좌: `row, col - 1`
- 우: `row, col + 1`

이동할 때 배열의 경계를 넘어가는지 확인하는 것이 중요합니다.

### 예시 코드

```cpp
#include <iostream>
using namespace std;

// 문제의 정의:
// n x n 크기의 2차원 배열이 주어졌을 때, 특정 위치에서 상하좌우로 이동할 수 있는지 여부를 판단하고, 이동 가능한 위치의 값을 출력하는 프로그램을 작성하세요.
// 배열의 경계를 벗어나는 경우에는 경고 메시지를 출력합니다.

// 예시 입력:
// n = 5
// matrix = {
//     {1, 2, 3, 4, 5},
//     {6, 7, 8, 9, 10},
//     {11, 12, 13, 14, 15},
//     {16, 17, 18, 19, 20},
//     {21, 22, 23, 24, 25}
// }
// 시작점: (2, 2)

// 예시 출력:
// 현재 위치: (2, 2) 값: 13
// 이동한 위치: (1, 2) 값: 8
// 이동한 위치: (3, 2) 값: 18
// 이동한 위치: (2, 1) 값: 12
// 이동한 위치: (2, 3) 값: 14

// 배열의 경계를 넘어가는지 확인하는 함수
bool isValidMove(int x, int y, int n) {
    return (x >= 0 && x < n && y >= 0 && y < n);
}

int main() {
    int n = 5; // 배열의 크기
    int matrix[5][5] = { // n x n 배열 초기화
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9, 10},
        {11, 12, 13, 14, 15},
        {16, 17, 18, 19, 20},
        {21, 22, 23, 24, 25}
    };

    int startX = 2, startY = 2; // 시작점 (2, 2)
    int dx[] = {-1, 1, 0, 0}; // 상하좌우 이동을 위한 x 변화량
    int dy[] = {0, 0, -1, 1}; // 상하좌우 이동을 위한 y 변화량

    // 현재 위치와 값 출력
    cout << "현재 위치: (" << startX << ", " << startY << ") 값: " << matrix[startX][startY] << endl;

    // 상하좌우로 이동 가능 여부 확인 및 이동 후 위치와 값 출력
    for (int i = 0; i < 4; i++) {
        int newX = startX + dx[i];
        int newY = startY + dy[i];

        // 경계 내에 있는지 확인
        if (isValidMove(newX, newY, n)) {
            // 경계 내에 있으면 이동한 위치와 값을 출력
            cout << "이동한 위치: (" << newX << ", " << newY << ") 값: " << matrix[newX][newY] << endl;
        } else {
            // 경계를 벗어난 경우 경고 메시지 출력
            cout << "위치 (" << newX << ", " << newY << ")는 배열의 경계를 벗어남." << endl;
        }
    }

    return 0;
}

```

### 코드 설명
이 코드에서는 2차원 배열 내에서 상하좌우로 이동하는 방법을 구현했습니다. `isValidMove` 함수는 배열의 경계를 체크하여 유효한 이동인지 확인합니다. `main` 함수에서는 시작점에서 네 방향으로 이동을 시도하고, 그 결과를 출력합니다.

---

이 문서는 배열을 다루는 세 가지 기본 개념에 대한 설명과 예시 코드를 제공합니다. 각 코드에는 상세한 주석이 포함되어 있어, 개념을 이해하고 직접 적용하는 데 도움을 줄 것입니다.
