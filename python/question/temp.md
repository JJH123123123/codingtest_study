
# 1. 리스트의 기본 개념
리스트는 파이썬에서 가장 많이 사용되는 데이터 구조 중 하나로, 여러 개의 데이터를 순차적으로 저장할 수 있는 가변 길이 배열입니다. 리스트는 대괄호 `[]`를 사용해 정의하며, 각 원소는 쉼표 `,`로 구분됩니다. 리스트는 다양한 데이터 타입을 혼합해서 저장할 수 있으며, 인덱스를 통해 개별 요소에 접근할 수 있습니다.


## 1.1 리스트 초기화 방법

리스트를 초기화하는 여러 방법을 살펴보겠습니다.

### 정수만 있는 리스트
```python
# 정수 리스트 예제
int_list = [1, 2, 3, 4, 5]
print(int_list[0])  # 첫 번째 요소에 접근 -> 1
print(int_list[-1])  # 마지막 요소에 접근 -> 5
```

### 문자열만 있는 리스트
```python
# 문자열 리스트 예제
str_list = ['apple', 'banana', 'cherry']
print(str_list[0])  # 첫 번째 요소에 접근 -> 'apple'
print(str_list[-1])  # 마지막 요소에 접근 -> 'cherry'
```

### 빈 리스트 초기화
```python
# 빈 리스트 예제
empty_list = []
print(empty_list)  # 빈 리스트 출력 -> []
```

### 리스트 컴프리헨션을 사용한 초기화
```python
# 리스트 컴프리헨션 예제
squares = [x ** 2 for x in range(5)]
print(squares)  # 제곱수를 가진 리스트 -> [0, 1, 4, 9, 16]
```


# 2. 리스트의 효율성
| 메서드명   | 동작                               | 리턴값           | 시간 복잡도   | 비고                                                 |
|:-----------|:-----------------------------------|:-----------------|:--------------|:-----------------------------------------------------|
| append()   | 리스트의 마지막에 원소를 추가      | None             | O(1)          |                                                      |
| insert()   | 리스트의 특정 위치에 원소를 삽입   | None             | O(n)          | 삽입 위치 이후의 모든 요소를 이동해야 함             |
| pop()      | 리스트의 마지막 원소를 제거        | 제거된 원소      | O(1)          |                                                      |
| pop(i)     | 리스트의 i번째 원소를 제거         | 제거된 원소      | O(n)          | i번째 원소를 제거한 후 i 이후의 요소들을 이동해야 함 |
| remove()   | 리스트에서 특정 원소를 제거        | None             | O(n)          | 제거할 원소를 찾기 위해 선형 탐색이 필요함           |
| index()    | 리스트에서 특정 값의 인덱스를 반환 | 찾은 값의 인덱스 | O(n)          | 찾으려는 값의 위치를 선형 탐색으로 찾음              |

## 리스트 메서드 시간 복잡도 예제 코드

### append() - 리스트의 마지막에 원소 추가
```python
my_list = [1, 2, 3]
my_list.append(4)  # O(1)
print(my_list)  # [1, 2, 3, 4]

# insert() - 리스트의 특정 위치에 원소 삽입
my_list.insert(1, 1.5)  # O(n)
print(my_list)  # [1, 1.5, 2, 3, 4]

#  pop() - 리스트의 마지막 원소 제거
```python
removed_item = my_list.pop()  # O(1)
print(removed_item)  # 4
print(my_list)  # [1, 1.5, 2, 3]

#  pop(1) - 리스트의 두 번째 원소 제거
removed_second_item = my_list.pop(1)  # O(n)
print(removed_second_item)  # 1.5
print(my_list)  # [1, 2, 3]

# remove() - 리스트에서 특정 원소 제거
my_list.remove(2)  # O(n)
print(my_list)  # [3]

# index() - 리스트에서 특정 값의 인덱스 반환
index_of_three = my_list.index(3)  # O(n)
print(index_of_three)  # 0
```

# 3. 튜플
- **튜플의 개념과 리스트와의 차이점**: 튜플은 리스트와 유사하지만, 한 번 정의되면 변경할 수 없는 불변(immutable) 데이터 구조입니다. 튜플은 소괄호 `()`를 사용해 정의하며, 리스트와 달리 데이터를 변경, 추가, 삭제할 수 없습니다.

```python
# 튜플 예제
my_tuple = (1, 2, 3)
# my_tuple[0] = 0  # 튜플은 불변이므로 값을 변경할 수 없습니다. 이 줄은 에러를 발생시킵니다.
print(my_tuple[1])  # 인덱스를 사용하여 접근 -> 2
```

- **튜플 사용이 적합한 경우**: 튜플은 데이터의 변경이 필요 없고, 고정된 데이터 집합을 표현할 때 적합합니다. 예를 들어, 함수의 반환값을 여러 개 반환하고자 할 때 튜플을 자주 사용합니다.

```python
# 튜플을 사용하는 함수 반환 예제
def get_coordinates():
    return (10, 20)  # (x, y) 좌표를 튜플로 반환

coords = get_coordinates()
print(coords)  # (10, 20)
```

# 4. 셋(Set)
- **셋의 개념과 특징**: 셋은 중복된 데이터를 허용하지 않는 데이터 구조로, 데이터의 순서가 중요하지 않은 경우에 사용됩니다. 셋은 중괄호 `{}`를 사용해 정의하며, 각 요소는 고유해야 합니다.

```python
# 셋 예제
my_set = {1, 2, 2, 3, 4}  # 2가 두 번 들어가 있지만, 중복은 제거됩니다.
print(my_set)  # {1, 2, 3, 4}
```

- **셋과 리스트의 차이점**: 셋은 중복된 값을 허용하지 않으며, 데이터의 순서가 중요하지 않습니다. 반면 리스트는 중복된 값을 허용하며, 데이터의 순서가 중요합니다.

```python
# 리스트와 셋의 차이점 예제
my_list = [1, 2, 2, 3, 4]
my_set = set(my_list)  # 리스트를 셋으로 변환하면 중복이 제거됩니다.
print(my_list)  # [1, 2, 2, 3, 4]
print(my_set)   # {1, 2, 3, 4}
```

# 5. 딕셔너리
- **딕셔너리의 개념**: 딕셔너리는 키-값 쌍으로 이루어진 데이터 구조로, 각 키는 고유하며, 이를 통해 값을 빠르게 검색할 수 있습니다. 딕셔너리는 중괄호 `{}`를 사용해 정의합니다.

```python
# 딕셔너리 예제
my_dict = {'name': 'Alice', 'age': 25}
print(my_dict['name'])  # 키를 사용해 값에 접근 -> 'Alice'
```

- **딕셔너리 키로 사용될 수 있는 데이터 타입과 이유**: 딕셔너리의 키로 사용될 수 있는 데이터 타입은 변경 가능한(immutable) 타입이어야 합니다. 이는 키가 변경될 수 없어야 딕셔너리가 내부적으로 데이터를 효율적으로 관리할 수 있기 때문입니다. 따라서 문자열, 숫자, 튜플 등이 키로 사용될 수 있습니다.

```python
# 딕셔너리 키로 사용될 수 있는 데이터 타입 예제
valid_dict = {(1, 2): 'Tuple as key', 'name': 'String as key'}  # 튜플과 문자열이 키로 사용됨
print(valid_dict[(1, 2)])  # 'Tuple as key'
```

- **딕셔너리에서 키-값 쌍의 삽입, 삭제 시간 복잡도**: 딕셔너리에서 키-값 쌍을 삽입하거나 삭제하는 연산의 시간 복잡도는 평균적으로 O(1)입니다.

```python
# 딕셔너리 삽입, 삭제 시간 복잡도 예제
my_dict['location'] = 'Wonderland'  # 삽입 -> O(1)
del my_dict['age']  # 삭제 -> O(1)
print(my_dict)  # {'name': 'Alice', 'location': 'Wonderland'}
```
